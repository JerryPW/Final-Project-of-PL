# SJTU CS2612 程序语言与编译原理课程大作业：寄存器分配

## 项目简介
本次项目作业利用课上所讲授的liveness分析方法,在一段程序已经做好基本快生成的情况下，进行寄存器分配，具体实现的功能有：  
* liveness分析
* 寄存器分配
* 汇编代码生成
* 在考虑系统调用的函数情况下对caller与callee saved寄存器进行了处理

## 如何使用
* 主程序为```backend_complier.cpp```，待分配程序以```output.txt```文档的形式给出，直接编译运行```backend_complier.cpp```即可对```output.txt```内的程序进行寄存器分配
* ```rg_cnt```维护了本次中寄存器可供分配的最大数量，修改```rg_cnt```的值可以改变寄存器分配的数量。（在实际使用时，考虑到实际的体系结构，我们允许的最大可使用寄存器数目是18.）

## 各部分具体功能简介
1. liveness分析：
   * 对每一条指令提取use与def集合
   * 根据整体程序之间的联系计算每一条指令中liveness的变量
2. 寄存器分配：
   * 完成基本操作：simplify，coalesce，freeze，spill
   * 遇到真spill情况对程序进行改写，引入将数据存取于内存的指令
3. 汇编代码生成：
   * 选取RISC-V作为汇编输出
   * 实现每一条指令的汇编生成
4. 函数调用中caller与callee saved寄存器考虑
   * 本项目中所有函数调用只考虑svc系统调用，因为在一个基本块中，倘若出现其余函数跳转，其理应作为一个新的基本块生成，而非以函数的形式出现在基本块中
   * 我们将待分配寄存器的整个程序看作一个被调用函数，即在整个```output.txt```中，只有程序本身作为callee，需要考虑callee_saved寄存器问题，其余情况下的函数调用，我们以caller视角，仅考虑caller_saved寄存器问题
   * 曹钦翔老师对于此部分的建议是：引入临时变量对寄存器值进行保存，并对临时变量进行liveness分析，但由于引入临时变量，其会导致inference graph之间联系极其复杂；我们最初的想法就是简单的在汇编层面将所需备份的写入栈中，但曹钦翔老师认为这样对内存的占用较大。对此，我们进行了折衷：对于caller_saved寄存器，若考虑临时变量法，其liveness区域包含从函数调用前一行到函数调用后一行，在此范围内，如果有寄存器与该变量不冲突，则将该寄存器分配给临时变量；如果所有寄存器均冲突，则将其写入内存中。对于callee_saved寄存器，它的livenss区域覆盖整个程序，如果在整体做完寄存器分配后仍有空闲寄存器，就将其分配给callee_saved寄存器的临时变量，否则，也将其写入内存中。
